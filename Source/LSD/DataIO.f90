! -*- f90 -*-
MODULE DataIO
!==============================================================================
  IMPLICIT NONE
  PRIVATE
  !! Several routines related to the input of necessary data
  
  public ReadUserInput, ReadData, WriteData, GetSize, ModelVALD
  
  ! Read the contents of the file UserInput.dat
  interface ReadUserInput
      subroutine ReadUserInput(spec, model, varfile, resultfile, wb, we, regular, nlsd, llim, vb, ve)
          Use FortranGeneral
          implicit none
          type(dataset), intent(inout) :: spec
          type(dataset), allocatable, intent(inout) :: model(:)
          character(len=*), intent(inout) :: varfile, resultfile
          double precision, intent(inout) :: wb, we, regular
          integer, intent(inout) :: nlsd
          double precision, allocatable, intent(inout) :: llim(:), vb(:), ve(:)
      end subroutine ReadUserInput
  end interface
  
  ! Read a single (i.e. a spectrum) or multiple (i.e. models) data files
  interface ReadData
      subroutine ReadMulti(filename, data, datasize)
          implicit none
          character(len=*), intent(in) :: filename(:)
          double precision, dimension(:,:), allocatable, intent(inout) :: data
          integer, allocatable, intent(inout) :: datasize(:)
      end subroutine ReadMulti
      
      subroutine ReadSingle(filename, data)
          implicit none
          character(len=*), intent(in) :: filename
          double precision, dimension(:,:), allocatable, intent(inout) :: data
      end subroutine ReadSingle
  end interface
  
  ! Find out how large a given data file is, in terms of amount of data (i.e. NOT file size!)
  interface GetSize
      subroutine GetSize(ffile,sz)
          implicit none
          character(len=*), intent(in) :: ffile
          integer, intent(inout) :: sz
      end subroutine
  end interface
  
  ! Read in a data file as generated by the VALD website (currently not used!)
  interface ModelVALD
      subroutine ModelVALD(ffile, valddata)
          implicit none
          character(len=*),intent(in) :: ffile
          double precision, intent(inout) :: valddata(:,:)
      end subroutine
  end interface
  
  ! Write the found solutions away in a data file
  interface WriteData
      subroutine WriteData(data, filename)
          implicit none
          double precision, intent(in) :: data(:,:)
          character(len=*), intent(in) :: filename
      end subroutine WriteData
  end interface
  
END MODULE DataIO



SUBROUTINE ReadUserInput(spec, model, varfile, resultfile, wb, we, regular, nlsd, llim, vb, ve)
  ! Subroutine used to read in the file 'UserInput.dat', containing the locations of the 
  ! observed spectrum, the model and where the results are supposed to be saved.
  ! It also contains values for other relevant parameters.
  Use FortranGeneral
  IMPLICIT NONE
  type(dataset), intent(inout) :: spec
  type(dataset), allocatable, intent(inout) :: model(:)
  character(len=*), intent(inout) :: varfile, resultfile
  double precision, intent(inout) :: wb, we, regular
  integer, intent(inout) :: nlsd
  double precision, allocatable, intent(inout) :: llim(:), vb(:), ve(:)
  character(len=150) :: tmp
  integer :: ios, i, NrModels
  
  open(unit=01, file='UserInput.dat', status="old", action="read", iostat=ios)
  
  if (ios /= 0) then
        print *, 'STATUS: ',ios
        stop "ERROR: DataIO: ReadUserInput the file was either empty or not opened properly."
  end if
  
  ! Determine the number of given models
  NrModels = 0
  
  do
      read(01,*, iostat= ios) tmp
      if (ios /= 0) exit
      if(tmp == 'Model') NrModels = NrModels + 1
  end do
  
  ios = 0
  rewind(unit=01)
  
  
  read(01,'(16x,A)') tmp
  spec%name = './Data/Spectra'//trim(tmp)
  read(01,'(16x,A)') tmp
  varfile = './Data/Spectra'//trim(tmp)
  read(01, '(16x,f6.0)') wb 
  read(01, '(16x,f6.0)') we
  read(01, *)
  read(01,'(16x,f8.6)') regular
  read(01,'(16x,A)') tmp
  resultfile = './Data/Results'//trim(tmp)
  read(01,*)
  read(01,'(16x,I2)') nlsd
  allocate(llim(nlsd-1))
  read(01,'(16x,5(f5.3,1x))') (llim(i), i=1,nlsd-1)
  read(01,*)
  
  
  allocate(model(NrModels),vb(NrModels),ve(NrModels))
  
  do i=1,NrModels
      read(01, '(16x,A)') tmp
      model(i)%name = './Data/Models'//trim(tmp)
      read(01, '(16x,f6.0)') vb(i)
      read(01, '(16x,f6.0)') ve(i)
      if(i < NrModels) read(01,*)
  end do
  
  close(unit=01)
  
END SUBROUTINE



SUBROUTINE ReadMulti(filename, data, datasize)
    ! Read in the data of a given data file
    USE DataIO
    
    IMPLICIT NONE
    character(len=*), intent(in) :: filename(:)
    double precision, allocatable, intent(inout) :: data(:,:)
    integer, allocatable, intent(inout) :: datasize(:)
    integer :: ios, i, k, nlen, temp2
    character :: ffile*(len(filename(1))), temp1*(2)
    
    
    allocate(datasize(size(filename)))
    
    do k = 1,size(filename)
        call GetSize(trim(filename(k)),datasize(k))
    end do
    
    allocate(data(sum(datasize),2))
    do k = 1,size(filename)
        nlen = len_trim(filename(k))
        ffile = filename(k)
        
        if (ffile(15:18) == 'VALD') then
            call ModelVALD(trim(ffile),data(1+sum(datasize(:k-1)):sum(datasize(:k)),:))
        
        else 
            open(unit=01, file=trim(ffile), status="old", action="read", iostat=ios)
            
            if (ios /= 0) then
                print *,'STATUS: ',ios
                stop "ERROR: DataIO: ReadData: the file could not be opened."
            end if
        
            if (ffile(nlen-3:) == '.lin') then
                
                do i=1,datasize(k)
                    read(01,*,iostat=ios) data(sum(datasize(:k-1))+i,1),temp1,temp2, data(sum(datasize(:k-1))+i,2)
                end do
                
            else ! Assume the file has has two columns
                
                do i=1,datasize(k)
                    read(01,*,iostat=ios) data(sum(datasize(:k-1))+i,1), data(sum(datasize(:k-1))+i,2)
                end do
            
            end if
            
            close(unit=01)
            
        end if
        
        do i=1,datasize(k)
            if(ISNAN(data(sum(datasize(:k-1))+i,2))) data(sum(datasize(:k-1))+i,2) = 0
            if(data(sum(datasize(:k-1))+i,2) < 0) data(sum(datasize(:k-1))+i,2) = 0
        end do
        
    end do
    
END SUBROUTINE ReadMulti


SUBROUTINE ReadSingle(filename, data)
    USE DataIO
    
    IMPLICIT NONE
    character(len=*), intent(in) :: filename
    double precision, allocatable, intent(inout) :: data(:,:)
    integer :: ios, i, k, datasize, temp2
    character :: temp1*(2)
    
    
    call GetSize(filename,datasize)
    
    allocate(data(datasize,2))
    
    if (filename(15:18) == 'VALD') then
        
        call ModelVALD(filename,data)
        
    else 
        
        open(unit=01, file=filename, status="old", action="read", iostat=ios)
                
        if (ios /= 0) then
            print *, 'STATUS: ',ios
            stop "ERROR: DataIO: ReadData: the file could not be opened."
        end if
        
        if (filename(len(filename)-3:) == '.lin') then
            
            do i=1,datasize
                read(01,*,iostat=ios) data(i,1), temp1, temp2, data(i,2)
            end do
        
        else ! Assume the file has has two columns
            
            do i=1,datasize
                read(01,*,iostat=ios) data(i,1), data(i,2)
            end do
            
        end if
        
        close(unit=01)
        
    end if
    
    do i=1,datasize
        if(ISNAN(data(i,2))) data(i,2) = 0
        if(data(i,2) < 0) data(i,2) = 0
    end do
    
END SUBROUTINE ReadSingle



SUBROUTINE GetSize(ffile,sz)
    IMPLICIT NONE
    character(len=*), intent(in) :: ffile
    integer, intent(inout) :: sz
    integer :: ios, nlines(3)
    
    if (ffile(15:18) == 'VALD') then
        
        open(unit=01, file=ffile, status="old", action="read", iostat=ios)
        
        if (ios /= 0) then
            print *, 'STATUS: ',ios
            stop "ERROR: DataIO: GetSize: the VALDfile was either empty or not opened properly."
        end if
        
        read(01,*) nlines
        sz = nlines(3)
        
    else 
        
        open(unit=01, file=ffile, status="old", action="read", iostat=ios)
        
        if (ios /= 0) then
            print *, 'STATUS: ',ios
            stop "ERROR: DataIO: GetSize: the file could not be opened."
        end if
        
        sz = 0
        
        do
            read(01,*, iostat= ios)
            if (ios /= 0) exit
            sz = sz + 1
        end do
        
    end if
    
    close(unit=01)
  
    
    return
    
END SUBROUTINE GetSize
    
    
SUBROUTINE ModelVALD(ffile, valddata)
    ! Read in the data (wavelengths; central line depths) from the file 'filename'
    ! generated by VALD.
    IMPLICIT NONE
    character(len=*),intent(in) :: ffile
    double precision, intent(inout) :: valddata(:,:)
    integer :: i, ios
    integer, dimension(3) :: nlines
    
    
    open(unit=01, file=ffile, status="old", action="read", iostat=ios)
    
    if (ios /= 0) then
        print *, 'STATUS: ',ios
        stop "ERROR: DataIO: ModelVALD: the file was either empty or not opened properly."
    end if
    
    read(01,*) nlines; read(01,*); read(01,*)
    
    do i = 1,nlines(3)
        read(01,'(7x,f10.4,51x,f6.3,32x)') valddata(i,1), valddata(i,2)
    end do
    
    valddata(:,2) = 1. - valddata(:,2)
    
    close(unit=01)
    
END SUBROUTINE


SUBROUTINE WriteData(data, filename)
    ! Write the data 'data' to file 'filename'
    Use FortranGeneral
    IMPLICIT NONE
    
    double precision, intent(in) :: data(:,:)
    character(len=*), intent(in) :: filename
    integer :: Open_Status, row, col, max_rows, max_cols
    
    open(unit=02, file=filename, status="replace", action = "write", IOSTAT = Open_Status)
    
    if (Open_Status /= 0) THEN
        print *,'STATUS: ',Open_Status
        STOP "ERROR: DataIO: WriteData: the file was not opened properly."
    end if
    
    do row = 1, size(data(:,1))
        write(02, '(es21.14,t30,es21.14)') (data(row,col), col = 1, size(data(1,:)))
    end do
    
    close(unit=02)
    
END SUBROUTINE
